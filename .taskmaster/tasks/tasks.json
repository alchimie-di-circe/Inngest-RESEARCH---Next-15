{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Extend Database Schema for Full Research Publishing Suite",
        "description": "Update Prisma schema with complete data models for research_jobs, brand_config, content_items, and publishing_queue tables as specified in the PRD to support all 4 phases.",
        "details": "Update `prisma/schema.prisma` with the following models:\n\n```prisma\nmodel ResearchJob {\n  id           String        @id @default(cuid())\n  topic        String\n  tabType      String        // 'deep', 'context', 'content', 'publish'\n  parameters   Json?\n  status       String        @default(\"pending\") // pending, running, completed, failed\n  reportData   Json?\n  createdAt    DateTime      @default(now())\n  completedAt  DateTime?\n  createdBy    String?\n  contentItems ContentItem[]\n  @@index([status])\n  @@index([createdAt])\n}\n\nmodel BrandConfig {\n  id             String   @id @default(cuid())\n  name           String\n  tovGuidelines  String?  @db.Text // Tone of voice\n  brandKnowledge Json?\n  platformHistory Json?\n  brandColors    Json?\n  logoUrl        String?\n  createdAt      DateTime @default(now())\n  updatedAt      DateTime @updatedAt\n  createdBy      String?\n}\n\nmodel ContentItem {\n  id            String           @id @default(cuid())\n  researchJobId String\n  researchJob   ResearchJob      @relation(fields: [researchJobId], references: [id], onDelete: Cascade)\n  contentType   String           // 'blog_post', 'social_post', 'carousel'\n  copy          String?          @db.Text\n  designAssets  Json?\n  status        String           @default(\"draft\") // draft, approved, rejected, published\n  platform      String           // 'blog', 'twitter', 'linkedin', 'instagram', 'multi'\n  publishDate   DateTime?\n  createdAt     DateTime         @default(now())\n  updatedAt     DateTime         @updatedAt\n  publishingQueue PublishingQueue[]\n  @@index([status])\n}\n\nmodel PublishingQueue {\n  id            String      @id @default(cuid())\n  contentItemId String\n  contentItem   ContentItem @relation(fields: [contentItemId], references: [id], onDelete: Cascade)\n  platform      String\n  scheduledAt   DateTime?\n  publishedAt   DateTime?\n  status        String      @default(\"pending\") // pending, published, failed\n  errorLog      String?     @db.Text\n  retryCount    Int         @default(0)\n  createdAt     DateTime    @default(now())\n  @@index([status])\n  @@index([platform])\n}\n\nmodel AgentAuditLog {\n  id         String   @id @default(cuid())\n  agentName  String\n  action     String\n  jobId      String?\n  status     String\n  metadata   Json?\n  createdAt  DateTime @default(now())\n  @@index([agentName])\n  @@index([createdAt])\n}\n```\n\nThen run `npx prisma db push` to sync with Neon. Create a database utility file at `src/lib/db.ts` to export Prisma client singleton.",
        "testStrategy": "Run `npx prisma validate` to check schema. Run `npx prisma db push --dry-run` to verify migration. Create integration tests in `tests/integration/db/schema.test.ts` that verify all tables can be created and basic CRUD operations work.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Core Models with Relations to Prisma Schema",
            "description": "Add the 5 new models (ResearchJob, BrandConfig, ContentItem, PublishingQueue, AgentAuditLog) to the Prisma schema with proper field definitions, relations, and cascade delete behaviors. Integrate with or deprecate existing ResearchContext and AgentRun models.",
            "dependencies": [],
            "details": "Update `prisma/schema.prisma` to add:\n\n1. **ResearchJob** model with fields: id, topic, tabType ('deep'|'context'|'content'|'publish'), parameters (Json), status ('pending'|'running'|'completed'|'failed'), reportData (Json), createdAt, completedAt, createdBy. Add one-to-many relation to ContentItem.\n\n2. **BrandConfig** model with fields: id, name, tovGuidelines (Text for tone of voice), brandKnowledge (Json), platformHistory (Json), brandColors (Json), logoUrl, createdAt, updatedAt, createdBy. Standalone model.\n\n3. **ContentItem** model with fields: id, researchJobId (FK), contentType, copy (Text), designAssets (Json), status ('draft'|'approved'|'rejected'|'published'), platform, publishDate, createdAt, updatedAt. Relation to ResearchJob with onDelete Cascade. One-to-many relation to PublishingQueue.\n\n4. **PublishingQueue** model with fields: id, contentItemId (FK), platform, scheduledAt, publishedAt, status ('pending'|'published'|'failed'), errorLog (Text), retryCount, createdAt. Relation to ContentItem with onDelete Cascade.\n\n5. **AgentAuditLog** model with fields: id, agentName, action, jobId, status, metadata (Json), createdAt. Standalone model for audit trail.\n\nConsider keeping existing models as-is for backward compatibility or add deprecation comments if they're superseded by new models.",
            "status": "pending",
            "testStrategy": "Run `npx prisma validate` to verify schema syntax is correct. Check that all relations compile without circular dependency errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Database Indexes and Constraints",
            "description": "Add performance-critical indexes to all models for common query patterns (status filtering, date sorting, platform filtering) as specified in the PRD schema.",
            "dependencies": [
              1
            ],
            "details": "Add the following `@@index` directives to optimize query performance:\n\n**ResearchJob:**\n- `@@index([status])` - For filtering by job status (pending, running, completed, failed)\n- `@@index([createdAt])` - For sorting/filtering by creation date\n\n**ContentItem:**\n- `@@index([status])` - For filtering draft/approved/published content\n\n**PublishingQueue:**\n- `@@index([status])` - For finding pending/failed publishing jobs\n- `@@index([platform])` - For platform-specific queue queries\n\n**AgentAuditLog:**\n- `@@index([agentName])` - For filtering logs by agent\n- `@@index([createdAt])` - For time-based log queries\n\nThese indexes align with the SQL schema in CLAUDE.md and support the query patterns needed for the publishing queue manager (Task 10) and real-time streaming (Task 13).",
            "status": "pending",
            "testStrategy": "Run `npx prisma db push --dry-run` to verify migration plan includes all expected CREATE INDEX statements. Review generated SQL to confirm index names and columns are correct.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Prisma Client Singleton and Type Exports",
            "description": "Create the database utility file at `src/lib/db.ts` with a Prisma client singleton pattern for serverless environments and export type helpers for all new models.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/lib/db.ts` with the following structure:\n\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n}\n\n// Type exports for all models\nexport type { ResearchJob, BrandConfig, ContentItem, PublishingQueue, AgentAuditLog } from '@prisma/client';\n\n// Convenience type aliases\nexport type ResearchJobStatus = 'pending' | 'running' | 'completed' | 'failed';\nexport type ContentStatus = 'draft' | 'approved' | 'rejected' | 'published';\nexport type PublishingStatus = 'pending' | 'published' | 'failed';\nexport type TabType = 'deep' | 'context' | 'content' | 'publish';\nexport type Platform = 'blog' | 'twitter' | 'linkedin' | 'instagram' | 'multi';\n```\n\nAfter creating the file, run `npx prisma generate` to ensure types are available, then `npx prisma db push` to sync schema with Neon database.",
            "status": "pending",
            "testStrategy": "Create `tests/integration/db/schema.test.ts` with tests that: 1) Import prisma from db.ts successfully, 2) Verify all 5 models are accessible via prisma client, 3) Test basic CRUD operations (create, read, update, delete) for each model, 4) Verify cascade deletes work for ResearchJob‚ÜíContentItem‚ÜíPublishingQueue chain.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the Prisma schema extension task into: 1) Adding core models (ResearchJob, BrandConfig, ContentItem, PublishingQueue, AgentAuditLog) with proper relations; 2) Adding indexes and constraints; 3) Creating database utility file with Prisma client singleton and type exports. Consider that the existing schema only has ResearchContext and AgentRun models which need to be integrated or replaced.",
        "updatedAt": "2026-01-25T20:16:58.312Z"
      },
      {
        "id": "2",
        "title": "Create Dashboard Layout with 4-Tab Navigation",
        "description": "Implement the dashboard shell with sidebar navigation and 4 phase tabs (Deep Research, Context Research, Content Generation, Publishing) using Next.js 15 app router.",
        "details": "Create the dashboard structure:\n\n1. Create `src/app/(dashboard)/layout.tsx`:\n```tsx\nimport { Sidebar } from '@/components/sidebar';\n\nexport default function DashboardLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <div className=\"flex h-screen bg-slate-950\">\n      <Sidebar />\n      <main className=\"flex-1 overflow-auto p-6\">{children}</main>\n    </div>\n  );\n}\n```\n\n2. Create `src/components/sidebar.tsx` with navigation links for 4 tabs:\n- Deep Research (`/deep`)\n- Context Research (`/context`)\n- Content Generation (`/content`)\n- Publishing (`/publishing`)\n\n3. Create page stubs:\n- `src/app/(dashboard)/deep/page.tsx`\n- `src/app/(dashboard)/context/page.tsx`\n- `src/app/(dashboard)/content/page.tsx`\n- `src/app/(dashboard)/publishing/page.tsx`\n\n4. Update `src/app/page.tsx` to redirect to `/deep` or show project selection\n\nUse Tailwind classes consistent with existing dark theme (slate-950, slate-800, etc.)",
        "testStrategy": "Create component tests for Sidebar using React Testing Library. Verify navigation links render correctly. E2E test with Playwright to verify tab switching works and maintains URL state.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dashboard Route Group with Layout",
            "description": "Create the (dashboard) route group directory structure and implement the layout.tsx file with flex container for sidebar and main content area.",
            "dependencies": [],
            "details": "Create `src/app/(dashboard)/layout.tsx` with the following structure:\n\n1. Create directory: `src/app/(dashboard)/`\n2. Implement layout.tsx as a server component:\n```tsx\nimport { Sidebar } from '@/components/sidebar';\n\nexport default function DashboardLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <div className=\"flex h-screen bg-slate-950\">\n      <Sidebar />\n      <main className=\"flex-1 overflow-auto p-6\">{children}</main>\n    </div>\n  );\n}\n```\n\nKey implementation details:\n- Use `h-screen` for full viewport height\n- Use `flex` layout with sidebar on left, main content on right\n- Apply `bg-slate-950` to match existing dark theme pattern from current page.tsx\n- Main area uses `flex-1` to take remaining space, `overflow-auto` for scrolling, `p-6` for consistent padding\n- Import Sidebar from @/components/sidebar (to be created in subtask 2)",
            "status": "pending",
            "testStrategy": "Verify the route group is recognized by Next.js app router. Check that layout wraps child pages correctly. Confirm dark theme background renders properly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Sidebar Navigation Component",
            "description": "Implement the Sidebar component with navigation links for the 4 phase tabs using existing dark theme patterns (slate-950, slate-800, indigo accents).",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/sidebar.tsx` as a client component:\n\n```tsx\n'use client';\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\n\nconst navItems = [\n  { href: '/deep', label: 'Deep Research', icon: 'üî¨' },\n  { href: '/context', label: 'Context Research', icon: 'üìã' },\n  { href: '/content', label: 'Content Generation', icon: '‚úçÔ∏è' },\n  { href: '/publishing', label: 'Publishing', icon: 'üì§' },\n];\n\nexport function Sidebar() {\n  const pathname = usePathname();\n  \n  return (\n    <aside className=\"w-64 bg-slate-900 border-r border-slate-700 p-4\">\n      <div className=\"mb-8\">\n        <h1 className=\"text-xl font-bold text-white\">Research Suite</h1>\n      </div>\n      <nav className=\"space-y-2\">\n        {navItems.map((item) => {\n          const isActive = pathname === item.href;\n          return (\n            <Link\n              key={item.href}\n              href={item.href}\n              className={`flex items-center gap-3 px-4 py-3 rounded-lg transition-colors ${\n                isActive\n                  ? 'bg-indigo-600 text-white'\n                  : 'text-slate-400 hover:bg-slate-800 hover:text-white'\n              }`}\n            >\n              <span>{item.icon}</span>\n              <span>{item.label}</span>\n            </Link>\n          );\n        })}\n      </nav>\n    </aside>\n  );\n}\n```\n\nTheme patterns from codebase:\n- `bg-slate-900` for sidebar background (nested bg level)\n- `border-r border-slate-700` for right border\n- `text-white` for headings, `text-slate-400` for inactive links\n- `bg-indigo-600 text-white` for active state (matches button pattern)\n- `hover:bg-slate-800 hover:text-white` for hover states\n- `transition-colors` for smooth transitions",
            "status": "pending",
            "testStrategy": "Create React Testing Library tests to verify all 4 navigation links render with correct hrefs. Test active state highlighting by mocking usePathname. Verify hover and transition classes are applied.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Page Stubs and Root Redirect",
            "description": "Create the 4 page stub files for /deep, /context, /content, /publishing routes and update root page.tsx to redirect to /deep as the default tab.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create 4 page stubs in the (dashboard) route group:\n\n`src/app/(dashboard)/deep/page.tsx`:\n```tsx\nexport default function DeepResearchPage() {\n  return (\n    <div className=\"space-y-6\">\n      <h1 className=\"text-2xl font-bold text-white\">Deep Research</h1>\n      <p className=\"text-slate-400\">Multi-agent staging ‚Üí reasoning ‚Üí reporting pipeline</p>\n      <div className=\"bg-slate-800 border border-slate-700 rounded-lg p-6\">\n        <p className=\"text-slate-300\">Deep Research interface coming soon...</p>\n      </div>\n    </div>\n  );\n}\n```\n\n`src/app/(dashboard)/context/page.tsx`:\n```tsx\nexport default function ContextResearchPage() {\n  return (\n    <div className=\"space-y-6\">\n      <h1 className=\"text-2xl font-bold text-white\">Context Research</h1>\n      <p className=\"text-slate-400\">Multi-source gathering + brand contextualization</p>\n      <div className=\"bg-slate-800 border border-slate-700 rounded-lg p-6\">\n        <p className=\"text-slate-300\">Context Research interface coming soon...</p>\n      </div>\n    </div>\n  );\n}\n```\n\n`src/app/(dashboard)/content/page.tsx`:\n```tsx\nexport default function ContentGenerationPage() {\n  return (\n    <div className=\"space-y-6\">\n      <h1 className=\"text-2xl font-bold text-white\">Content Generation</h1>\n      <p className=\"text-slate-400\">Unified text + design creation</p>\n      <div className=\"bg-slate-800 border border-slate-700 rounded-lg p-6\">\n        <p className=\"text-slate-300\">Content Generation interface coming soon...</p>\n      </div>\n    </div>\n  );\n}\n```\n\n`src/app/(dashboard)/publishing/page.tsx`:\n```tsx\nexport default function PublishingPage() {\n  return (\n    <div className=\"space-y-6\">\n      <h1 className=\"text-2xl font-bold text-white\">Publishing</h1>\n      <p className=\"text-slate-400\">Automated distribution to platforms</p>\n      <div className=\"bg-slate-800 border border-slate-700 rounded-lg p-6\">\n        <p className=\"text-slate-300\">Publishing interface coming soon...</p>\n      </div>\n    </div>\n  );\n}\n```\n\n2. Update `src/app/page.tsx` to redirect to /deep:\n```tsx\nimport { redirect } from 'next/navigation';\n\nexport default function Home() {\n  redirect('/deep');\n}\n```\n\nAlternatively, keep existing content but add a link to dashboard, or use `next.config.ts` redirects.",
            "status": "pending",
            "testStrategy": "E2E test with Playwright to verify: 1) Root URL redirects to /deep, 2) All 4 routes are accessible and render correct page titles, 3) Tab switching maintains URL state and highlights correct sidebar item.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the dashboard layout task into: 1) Creating the (dashboard) route group with layout.tsx containing flex sidebar + main layout; 2) Creating Sidebar component with 4 navigation links using existing dark theme (slate-950, etc.); 3) Creating 4 page stubs for /deep, /context, /content, /publishing and updating root redirect. Existing components use consistent Tailwind dark theme patterns to follow.",
        "updatedAt": "2026-01-25T20:17:04.661Z"
      },
      {
        "id": "3",
        "title": "Implement Brand Configuration Management",
        "description": "Create API routes and UI for managing brand configurations including tone of voice guidelines, brand colors, and platform history storage.",
        "details": "1. Create API routes at `src/app/api/brand/route.ts`:\n```typescript\n// GET - List all brand configs\n// POST - Create new brand config\nexport async function GET(request: Request) {\n  const brands = await prisma.brandConfig.findMany({\n    orderBy: { createdAt: 'desc' }\n  });\n  return Response.json(brands);\n}\n\nexport async function POST(request: Request) {\n  const body = await request.json();\n  const brand = await prisma.brandConfig.create({ data: body });\n  return Response.json(brand);\n}\n```\n\n2. Create `src/app/api/brand/[id]/route.ts` for GET/PUT/DELETE by ID\n\n3. Create types in `src/types/brand.ts`:\n```typescript\nexport interface BrandConfig {\n  id: string;\n  name: string;\n  tovGuidelines?: string;\n  brandKnowledge?: Record<string, unknown>;\n  platformHistory?: {\n    twitter?: string[];\n    linkedin?: string[];\n    shopify?: string[];\n  };\n  brandColors?: { primary: string; secondary: string; accent: string };\n  logoUrl?: string;\n}\n```\n\n4. Create UI components:\n- `src/components/brand/brand-form.tsx` - Form for creating/editing brands\n- `src/components/brand/brand-list.tsx` - List view of all brands\n- `src/components/brand/brand-selector.tsx` - Dropdown for selecting active brand",
        "testStrategy": "Unit tests for API routes using mocked Prisma client. Integration tests verifying CRUD operations against test database. Component tests for form validation and submission.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Brand API Routes with CRUD Operations",
            "description": "Implement the API routes at /api/brand and /api/brand/[id] for full CRUD operations on brand configurations, following the existing server action patterns in the codebase.",
            "dependencies": [],
            "details": "Create two API route files following existing patterns:\n\n1. `src/app/api/brand/route.ts`:\n   - GET: List all brand configs using `prisma.brandConfig.findMany({ orderBy: { createdAt: 'desc' } })`\n   - POST: Create new brand config with validation using `prisma.brandConfig.create({ data: body })`\n\n2. `src/app/api/brand/[id]/route.ts`:\n   - GET: Fetch single brand by ID using `prisma.brandConfig.findUnique({ where: { id } })`\n   - PUT: Update brand config using `prisma.brandConfig.update({ where: { id }, data: body })`\n   - DELETE: Remove brand config using `prisma.brandConfig.delete({ where: { id } })`\n\nFollow the existing error handling patterns seen in the codebase. Return appropriate HTTP status codes (200, 201, 404, 500). Use Response.json() for all responses. Ensure routes handle edge cases like missing brand IDs and validation errors.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked Prisma client for each CRUD operation. Test error handling for invalid IDs, missing required fields, and database errors. Integration tests against test database verifying data persistence.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define BrandConfig TypeScript Interface and Types",
            "description": "Create comprehensive TypeScript type definitions for BrandConfig interface in src/types/brand.ts, including all brand-related types for API contracts and component props.",
            "dependencies": [],
            "details": "Create `src/types/brand.ts` with the following type definitions:\n\n```typescript\nexport interface BrandColors {\n  primary: string;\n  secondary: string;\n  accent: string;\n}\n\nexport interface PlatformHistory {\n  twitter?: string[];\n  linkedin?: string[];\n  shopify?: string[];\n}\n\nexport interface BrandConfig {\n  id: string;\n  name: string;\n  tovGuidelines?: string;\n  brandKnowledge?: Record<string, unknown>;\n  platformHistory?: PlatformHistory;\n  brandColors?: BrandColors;\n  logoUrl?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateBrandConfigInput {\n  name: string;\n  tovGuidelines?: string;\n  brandKnowledge?: Record<string, unknown>;\n  platformHistory?: PlatformHistory;\n  brandColors?: BrandColors;\n  logoUrl?: string;\n}\n\nexport interface UpdateBrandConfigInput extends Partial<CreateBrandConfigInput> {}\n```\n\nFollow the existing interface-based pattern seen in `src/inngest/types.ts`. Export all types for use across API routes, components, and Inngest functions.",
            "status": "pending",
            "testStrategy": "TypeScript compilation check to ensure types are correctly defined. Verify type exports are accessible from other modules. No runtime tests needed for type definitions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build BrandForm Component with Full Field Support",
            "description": "Create brand-form.tsx component in src/components/brand/ with form fields for name, TOV guidelines, brand colors (primary/secondary/accent), logo URL, and platform history.",
            "dependencies": [
              2
            ],
            "details": "Create `src/components/brand/brand-form.tsx` following existing component patterns (QueryForm.tsx style):\n\n1. Use 'use client' directive for client-side interactivity\n2. Props interface: `{ initialData?: BrandConfig; onSubmit: (data: CreateBrandConfigInput) => Promise<void>; isLoading?: boolean }`\n3. Form fields using controlled components with useState:\n   - Name input (required, text)\n   - TOV Guidelines textarea (optional, multiline)\n   - Logo URL input (optional, URL validation)\n   - Brand Colors section with 3 color pickers (primary, secondary, accent)\n   - Platform History JSON editor or structured inputs for twitter/linkedin/shopify arrays\n4. Apply existing dark theme styling:\n   - Container: `bg-slate-800 rounded-lg p-6 border border-slate-700`\n   - Inputs: `w-full p-4 rounded-lg bg-slate-800 text-white border border-slate-700 focus:border-indigo-500`\n   - Submit button: `px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:opacity-50`\n5. Include form validation for required fields and URL format\n6. Handle both create and edit modes based on initialData prop",
            "status": "pending",
            "testStrategy": "Component tests for form rendering, validation, and submission. Test controlled input updates. Test form submission calls onSubmit with correct data. Test disabled state during loading.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create BrandList and BrandSelector Dropdown Components",
            "description": "Build brand-list.tsx for displaying all brands in a list/card view and brand-selector.tsx dropdown component for selecting the active brand in the research workflow.",
            "dependencies": [
              2
            ],
            "details": "Create two components in `src/components/brand/`:\n\n**1. brand-list.tsx:**\n- Props: `{ brands: BrandConfig[]; onEdit?: (id: string) => void; onDelete?: (id: string) => void; selectedId?: string }`\n- Display brands in card layout following AgentCard.tsx pattern\n- Each card shows: name, TOV preview (truncated), color swatches, logo thumbnail\n- Include edit and delete action buttons with confirmation for delete\n- Apply dark theme: `bg-slate-800 rounded-lg border border-slate-700`\n- Show empty state when no brands exist\n\n**2. brand-selector.tsx:**\n- Props: `{ brands: BrandConfig[]; selectedBrandId?: string; onSelect: (brandId: string) => void; disabled?: boolean }`\n- Dropdown/select component for choosing active brand\n- Show brand name and color preview in options\n- Style: `w-full p-3 rounded-lg bg-slate-800 text-white border border-slate-700`\n- Include 'None' option for no brand selection\n- Used in Context Research tab for applying brand context\n\nBoth components should be keyboard accessible and follow existing styling conventions.",
            "status": "pending",
            "testStrategy": "Component tests for rendering brand data correctly. Test selection callbacks fire with correct IDs. Test edit/delete actions trigger appropriate callbacks. Test empty state rendering. Test keyboard navigation for accessibility.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down brand configuration management into: 1) Creating API routes at /api/brand and /api/brand/[id] for CRUD operations; 2) Creating TypeScript types for BrandConfig interface; 3) Creating brand-form.tsx component with form fields for TOV guidelines, colors, logo, platform history; 4) Creating brand-list.tsx and brand-selector.tsx dropdown component. Depends on Task 1 for Prisma schema."
      },
      {
        "id": "4",
        "title": "Refactor Deep Research Agent for PRD Compliance",
        "description": "Update the existing deep research agent (gather-context, orchestrator) to align with PRD Feature 1.1-1.3, adding proper event schemas and database persistence.",
        "details": "1. Update `src/inngest/events.ts` to add new event types:\n```typescript\nexport type InngestEvents = {\n  'deep.research.requested': {\n    data: {\n      topic: string;\n      brandId?: string;\n      depth: number; // 1-5\n      breadth: number; // 1-5\n      userId: string;\n      sessionId: string;\n    };\n  };\n  'deep.research.completed': {\n    data: {\n      jobId: string;\n      reportData: DeepResearchReport;\n      sourcesCount: number;\n    };\n  };\n};\n```\n\n2. Modify `src/inngest/functions/orchestrator.ts`:\n- Enable Checkpointing (`checkpointing: true`) for lower latency execution\n- Accept 'deep.research.requested' event (in addition to existing)\n- Persist ResearchJob to database at start\n- Update job status as workflow progresses\n- Save final reportData to database\n- Emit 'deep.research.completed' event at end\n\n3. Add read_article tool integration in websearch.ts to fetch full articles\n\n4. Update gather-context to accept depth/breadth parameters and adjust search queries accordingly\n\n5. Update Deep Research page (`src/app/(dashboard)/deep/page.tsx`):\n- Add form for topic, depth, breadth parameters\n- Show research job history from database\n- Display real-time progress using existing RealtimeResearchStatus component",
        "testStrategy": "Integration tests for the full deep research pipeline using TestSprite MCP sandbox. Verify database persistence at each step. Test edge cases: no results found, API failures, retry logic.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Deep Research Event Types to events.ts",
            "description": "Create a dedicated events.ts file with deep.research.requested and deep.research.completed event type definitions including all required parameters (topic, brandId, depth, breadth, userId, sessionId).",
            "dependencies": [],
            "details": "1. Create `src/inngest/events.ts` if it doesn't exist (currently events are inline in client.ts)\n2. Define DeepResearchReport type for report data structure\n3. Add deep.research.requested event with: topic (string), brandId (optional string), depth (1-5 number), breadth (1-5 number), userId (string), sessionId (string)\n4. Add deep.research.completed event with: jobId (string), reportData (DeepResearchReport), sourcesCount (number)\n5. Export InngestEvents type union and update client.ts to import from events.ts\n6. Add Zod validation schemas for depth/breadth parameters (1-5 range validation)",
            "status": "pending",
            "testStrategy": "Unit tests verifying event type exports, Zod schema validation for depth/breadth ranges, TypeScript compilation check for type safety",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Modify Orchestrator to Accept New Event, Add Checkpointing and Database Persistence",
            "description": "Update orchestrator.ts to listen for deep.research.requested event, enable checkpointing for performance, create ResearchJob in database at workflow start, update job status during execution, and emit deep.research.completed on success.",
            "dependencies": [
              1
            ],
            "details": "1. Add second event trigger to orchestrator: { event: 'deep.research.requested' } alongside existing research/query.submitted\n2. Set `checkpointing: true` in createFunction options for lower latency\n3. At workflow start, use step.run('create-job') to persist ResearchJob to database with status='running'\n4. After gatherContext, update job status with step.run('update-job-staging')\n5. After agent fan-out/fan-in, update job status with step.run('update-job-analysis')\n6. On successful synthesis, save reportData to database and set status='completed', completedAt=now()\n7. Emit deep.research.completed event via inngest.send() with jobId, reportData, sourcesCount\n8. Wrap workflow in try/catch, update job status='failed' on error with error message in reportData\n9. Ensure database operations use Prisma with proper error handling",
            "status": "pending",
            "testStrategy": "Integration tests mocking database calls, verify job status transitions (pending‚Üírunning‚Üícompleted/failed), verify event emission on completion",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Depth/Breadth Parameters to Gather-Context Function",
            "description": "Extend gather-context.ts to accept depth and breadth parameters that control search query expansion, result counts per source, and context ranking thresholds.",
            "dependencies": [
              1
            ],
            "details": "1. Update gatherContext function signature to accept depth (1-5), breadth (1-5), and selectedMCPs array from event.data\n2. Depth affects: number of search variations per source, embedding comparison threshold, context ranking strictness\n3. Breadth affects: number of sources to query in parallel, max results per source (breadth * 5), total contexts returned (breadth * 10)\n4. REMOVE ArXiv and GitHub sources - replaced by new MCP integrations (Task 16-18)\n5. Use MCP Router to dynamically route queries to selected MCPs (Jina, Firecrawl, Reddit, Google Deep Research)\n6. Modify VectorDB query to adjust topK based on depth * breadth (VectorDB sempre attivo)\n7. Update context ranking threshold: higher depth = stricter relevance cutoff\n8. Add source diversity bonus in ranking (results from multiple MCPs rank higher)\n9. Default values: depth=3, breadth=3, selectedMCPs=['jina', 'reddit'] for backward compatibility",
            "status": "pending",
            "testStrategy": "Unit tests for parameter scaling logic, integration tests verifying different depth/breadth combinations produce expected result counts",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Deep Research Page with Form and Job History",
            "description": "Build or update the Deep Research page at src/app/(dashboard)/deep/page.tsx with a form for topic, depth, breadth inputs and a job history table fetching from database.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Create page at src/app/(dashboard)/deep/page.tsx with server component wrapper\n2. Add form with: topic (text input, required), depth (slider/select 1-5, default 3), breadth (slider/select 1-5, default 3)\n3. Add optional brandId selector if brand_config table has entries\n4. Create server action submitDeepResearch() that sends deep.research.requested event\n5. Add ResearchJobHistory client component that fetches jobs with tabType='deep' from API\n6. Display job history table with columns: topic, status, createdAt, completedAt, actions (view report)\n7. Integrate existing RealtimeResearchStatus component for real-time progress display\n8. Add status filters (all, pending, running, completed, failed) and pagination\n9. Style with existing Tailwind design system patterns from QueryForm.tsx",
            "status": "pending",
            "testStrategy": "Component tests for form validation, integration tests for form submission triggering events, E2E test verifying job appears in history after completion",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Report Display and Error Handling",
            "description": "Create a report viewer component for displaying deep research reports from database, with proper error boundaries and recovery UI for failed jobs.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Create DeepResearchReport component that renders reportData JSON as structured UI\n2. Add report sections: Executive Summary, Key Findings, Sources (with citations), Agent Analysis breakdown\n3. Implement error boundary wrapper around RealtimeResearchStatus to catch streaming errors\n4. Add retry button for failed jobs that re-emits deep.research.requested with same parameters\n5. Create API route GET /api/research/[jobId] to fetch single job with full reportData\n6. Add loading skeleton states for report sections\n7. Implement report export functionality (markdown, JSON download)\n8. Handle edge cases: empty report, partial completion, timeout states\n9. Add toast notifications for job status changes using existing notification patterns",
            "status": "pending",
            "testStrategy": "Unit tests for report rendering with various reportData shapes, component tests for error boundary behavior, integration tests for retry functionality",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down deep research refactoring into: 1) Updating events.ts with new deep.research.requested/completed event types; 2) Modifying orchestrator.ts to accept new event, enable checkpointing, persist ResearchJob at start, update status during workflow; 3) Adding depth/breadth parameters to gather-context.ts affecting search queries; 4) Implementing database persistence in orchestrator with error handling; 5) Updating Deep Research page with form for depth/breadth params and job history display. Existing orchestrator has solid multi-agent pattern to build upon."
      },
      {
        "id": "5",
        "title": "Implement Context Research Phase 2 Agent",
        "description": "Create the context research agent that analyzes deep research reports, applies brand context matching, and implements the multi-agent analysis network per PRD Feature 2.1-2.3.",
        "details": "1. Create `src/inngest/functions/context-research-agent.ts`:\n```typescript\nexport const contextResearchAgent = inngest.createFunction(\n  { \n    id: 'context-research-agent', \n    name: 'Context Research Agent', \n    checkpointing: true // Enable for low latency\n  },\n  { event: 'context.research.requested' },\n  async ({ event, step, publish }) => {\n    const { researchJobId, brandId, sessionId } = event.data;\n    \n    // Step 1: Fetch deep research report from DB\n    const researchJob = await step.run('fetch-research', async () => {\n      return await prisma.researchJob.findUnique({\n        where: { id: researchJobId }\n      });\n    });\n    \n    // Step 2: Fetch brand config\n    const brandConfig = await step.run('fetch-brand', async () => {\n      return await prisma.brandConfig.findUnique({\n        where: { id: brandId }\n      });\n    });\n    \n    // Step 3: Multi-agent analysis (pattern 2)\n    const analysisResults = await Promise.all([\n      step.invoke('theme-detector', { function: themeDetectorAgent, data: {...} }),\n      step.invoke('opportunity-analyzer', { function: opportunityAnalyzer, data: {...} }),\n      step.invoke('trend-identifier', { function: trendIdentifier, data: {...} })\n    ]);\n    \n    // Step 4: Apply brand context matching using dynamic system prompts\n    const contextualizedBrief = await step.run('brand-matching', async () => {\n      // Use Claude with brand TOV as system prompt\n    });\n    \n    return { contextualizedBrief, analysisResults };\n  }\n);\n```\n\n2. Create sub-agents in `src/inngest/functions/agents/`:\n- `theme-detector-agent.ts`\n- `opportunity-analyzer-agent.ts`\n- `trend-identifier-agent.ts`\n\n3. Add event types for context research in `src/inngest/client.ts`\n\n4. Create Context Research page with form to select research job and brand",
        "testStrategy": "Unit tests for each sub-agent in isolation. Integration test for full context research pipeline. Verify brand TOV is correctly applied to analysis output.",
        "priority": "high",
        "dependencies": [
          "1",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create context-research-agent.ts main orchestrator function",
            "description": "Implement the main context research agent that orchestrates the multi-agent analysis network, handles event triggers, fetches research reports and brand configs from database, and coordinates sub-agent invocation.",
            "dependencies": [],
            "details": "Create `src/inngest/functions/context-research-agent.ts` following the analyst-agent.ts pattern (115 lines). Define the inngest.createFunction with id 'context-research-agent', event trigger 'context.research.requested', retries: 2, checkpointing: true, and throttle config. Implement steps: 1) 'fetch-research' to query researchJob by researchJobId using prisma, 2) 'fetch-brand' to get brandConfig by brandId, 3) parallel step.invoke calls using Promise.all to fan-out to theme-detector, opportunity-analyzer, and trend-identifier agents (AgentKit Pattern 2), 4) 'brand-matching' step for brand context synthesis. Use researchChannel for realtime updates with 'agent-update' and 'agent-chunk' topics. Return { contextualizedBrief, analysisResults }.",
            "status": "pending",
            "testStrategy": "Unit test the main function with mocked prisma calls and step.invoke responses. Verify event handling for 'context.research.requested'. Test that all three sub-agents are invoked in parallel using Promise.all. Integration test the full orchestration flow with test database records.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create theme-detector-agent.ts sub-agent",
            "description": "Implement the theme detector sub-agent that analyzes research reports to identify key themes, patterns, and recurring topics for brand contextualization.",
            "dependencies": [
              1
            ],
            "details": "Create `src/inngest/functions/agents/theme-detector-agent.ts` following analyst-agent.ts structure. Define inngest.createFunction with id 'theme-detector-agent', event 'context/theme.detect', retries: 2, throttle: 10/min keyed by userId. Implement: 1) 'publish-theme-start' step with agent-update topic, 2) 'detect-themes' step using streamText with Claude model, system prompt instructing thematic analysis of research content. Input: researchReport JSON with findings and sources. Output structured themes: { primaryThemes: string[], secondaryThemes: string[], themeConnections: Array<{from, to, relationship}> }. Use publishTokenByTokenUpdates for streaming chunks to 'agent-chunk' topic.",
            "status": "pending",
            "testStrategy": "Unit test with mocked research report data. Verify streaming output publishes correctly to realtime channels. Test theme extraction accuracy with sample research reports. Test retry behavior on simulated API failures.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create opportunity-analyzer-agent.ts sub-agent",
            "description": "Implement the opportunity analyzer sub-agent that identifies content opportunities, gaps in existing content, and potential angles for brand messaging based on research findings.",
            "dependencies": [
              1
            ],
            "details": "Create `src/inngest/functions/agents/opportunity-analyzer-agent.ts` following analyst-agent.ts pattern. Define inngest.createFunction with id 'opportunity-analyzer-agent', event 'context/opportunity.analyze', retries: 2, throttle: 10/min. Implement: 1) 'publish-opportunity-start' step, 2) 'analyze-opportunities' step using Claude with system prompt for content gap analysis and opportunity identification. Input: researchReport + brandConfig (TOV guidelines, brand knowledge). Output: { opportunities: Array<{type, description, priority, relevantFindings}>, contentGaps: string[], suggestedAngles: string[] }. Stream analysis to 'agent-chunk' topic with agent='opportunity-analyzer'.",
            "status": "pending",
            "testStrategy": "Unit test with sample research data and brand configurations. Verify opportunity scoring logic. Test that brand TOV guidelines influence opportunity identification. Integration test with theme-detector output to ensure complementary analysis.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create trend-identifier-agent.ts sub-agent",
            "description": "Implement the trend identifier sub-agent that detects emerging trends, temporal patterns, and relevance signals from research data for timely content creation.",
            "dependencies": [
              1
            ],
            "details": "Create `src/inngest/functions/agents/trend-identifier-agent.ts` following analyst-agent.ts pattern. Define inngest.createFunction with id 'trend-identifier-agent', event 'context/trend.identify', retries: 2, throttle: 10/min. Implement: 1) 'publish-trend-start' step, 2) 'identify-trends' step using Claude with system prompt focused on trend detection, temporal analysis, and relevance scoring. Input: researchReport with timestamps and source metadata. Output: { emergingTrends: Array<{name, momentum, timeframe, sources}>, decliningTrends: string[], relevanceSignals: Array<{signal, strength, actionability}> }. Include trend velocity calculation logic. Stream to 'agent-chunk' topic.",
            "status": "pending",
            "testStrategy": "Unit test trend detection with time-series mock data. Verify momentum scoring algorithm. Test temporal pattern recognition with dated research entries. Integration test with opportunity-analyzer to ensure non-overlapping insights.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add context research event types and create Context Research UI page",
            "description": "Extend the Inngest client with new event types for context research workflow, update channels.ts with context-specific topics, and create the Context Research page component with research job and brand selection.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1) Update `src/inngest/client.ts` to add new event schemas: 'context.research.requested' (researchJobId, brandId, sessionId, userId), 'context/theme.detect', 'context/opportunity.analyze', 'context/trend.identify', 'context.research.completed'. 2) Extend channels.ts with 'context-progress' topic type<{stage: 'analysis' | 'brand-matching' | 'synthesis', progress: number, message: string, timestamp: string}>. Add context agent types to AgentUpdate and agent-chunk interfaces. 3) Create `src/app/research/context/page.tsx` with: dropdown to select completed research jobs (status='completed'), dropdown to select brand configs, trigger button calling POST /api/context-research, real-time progress display using researchChannel subscription, results display showing contextualizedBrief and sub-agent outputs.",
            "status": "pending",
            "testStrategy": "Type-check all new event schemas compile correctly. Component test Context Research page with mocked API responses. E2E test full flow: select research job ‚Üí select brand ‚Üí trigger ‚Üí view streaming progress ‚Üí display results. Verify realtime channel subscription updates UI correctly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down context research agent into: 1) Creating context-research-agent.ts main function with event handler; 2) Creating theme-detector-agent.ts sub-agent; 3) Creating opportunity-analyzer-agent.ts sub-agent; 4) Creating trend-identifier-agent.ts sub-agent; 5) Implementing brand context matching using dynamic system prompts and creating Context Research page. Use existing agent patterns from analyst-agent.ts (115 lines) as template."
      },
      {
        "id": "6",
        "title": "Implement Human-in-the-Loop Approval Workflow",
        "description": "Create the approval workflow using Inngest's wait-for-event pattern (AgentKit Pattern 3) to pause workflows and wait for user approval before proceeding.",
        "details": "1. Create `src/inngest/functions/approval-workflow.ts`:\n```typescript\nexport const approvalWorkflow = inngest.createFunction(\n  { id: 'approval-workflow' },\n  { event: 'approval.requested' },\n  async ({ event, step }) => {\n    const { itemId, itemType, userId, sessionId } = event.data;\n    \n    // Wait for approval (timeout: 7 days)\n    const approval = await step.waitForEvent('approval-response', {\n      event: 'approval.response',\n      match: 'data.itemId',\n      timeout: '7d'\n    });\n    \n    if (approval) {\n      if (approval.data.approved) {\n        // Emit continuation event\n        await step.sendEvent('continue-workflow', {\n          name: `${itemType}.approved`,\n          data: { itemId, approvedBy: approval.data.userId }\n        });\n      } else {\n        // Emit rejection event\n        await step.sendEvent('reject-workflow', {\n          name: `${itemType}.rejected`,\n          data: { itemId, reason: approval.data.reason }\n        });\n      }\n    }\n    \n    return { approved: approval?.data.approved ?? false };\n  }\n);\n```\n\n2. Create API route `src/app/api/approval/route.ts`:\n```typescript\nexport async function POST(request: Request) {\n  const { itemId, approved, reason, userId } = await request.json();\n  await inngest.send({\n    name: 'approval.response',\n    data: { itemId, approved, reason, userId }\n  });\n  return Response.json({ success: true });\n}\n```\n\n3. Create approval UI component `src/components/approval-prompt.tsx`:\n- Shows pending item details\n- Approve/Reject buttons\n- Optional rejection reason field\n\n4. Add approval states to content_items and research_jobs tables",
        "testStrategy": "Integration tests simulating approval flow: request ‚Üí wait ‚Üí approve/reject ‚Üí continuation. Test timeout behavior. Test rejection with reason flow.",
        "priority": "medium",
        "dependencies": [
          "1",
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create approval-workflow.ts Inngest function with waitForEvent pattern",
            "description": "Implement the core approval workflow Inngest function using step.waitForEvent() pattern to pause execution and wait for user approval decisions with a 7-day timeout.",
            "dependencies": [],
            "details": "Create `src/inngest/functions/approval-workflow.ts` with the approvalWorkflow function. The function should: 1) Listen for 'approval.requested' events; 2) Extract itemId, itemType, userId, sessionId from event data; 3) Use step.waitForEvent() to wait for 'approval.response' event with match on 'data.itemId' and 7-day timeout; 4) On approval, emit `${itemType}.approved` event with itemId and approvedBy; 5) On rejection, emit `${itemType}.rejected` event with itemId and reason; 6) Return approval status. Also add the new approval event types to src/inngest/client.ts EventSchemas: 'approval.requested', 'approval.response', 'content.approved', 'content.rejected', 'research.approved', 'research.rejected'. Register the new function in the Inngest serve() handler in src/app/api/inngest/route.ts.",
            "status": "pending",
            "testStrategy": "Integration test sending approval.requested event, then approval.response event, verifying the correct continuation event is emitted. Test timeout behavior by mocking time. Test both approval and rejection flows with various itemTypes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create /api/approval route for submitting approval decisions",
            "description": "Implement the API route that accepts approval/rejection decisions from the UI and emits the approval.response event to Inngest to resume paused workflows.",
            "dependencies": [
              1
            ],
            "details": "Create `src/app/api/approval/route.ts` with POST handler. The handler should: 1) Parse request body for itemId, approved (boolean), reason (optional string), userId; 2) Validate required fields (itemId, approved, userId); 3) Use the Inngest client to send 'approval.response' event with data: { itemId, approved, reason, userId }; 4) Return JSON response { success: true } on success; 5) Handle errors with appropriate status codes (400 for validation, 500 for Inngest errors). Also create a corresponding server action in src/app/actions.ts: submitApprovalDecision(itemId, approved, reason, userId) that calls this API endpoint for use with React Server Components.",
            "status": "pending",
            "testStrategy": "Unit tests for request validation (missing fields, invalid types). Integration test verifying Inngest event is sent with correct payload. Test error handling for Inngest client failures.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create approval-prompt.tsx UI component with approve/reject buttons",
            "description": "Build the React UI component that displays pending item details and provides approve/reject buttons with an optional rejection reason field.",
            "dependencies": [
              2
            ],
            "details": "Create `src/components/approval-prompt.tsx` component. Props: itemId, itemType, itemTitle, itemDescription, itemContent (the actual content to review), onApprovalComplete callback. Component should: 1) Display item details in a clear review format with title, description, and content preview; 2) Render Approve button (green) and Reject button (red); 3) On reject click, show a textarea for optional rejection reason; 4) Use the submitApprovalDecision server action to send decision; 5) Show loading state during submission; 6) Display success/error feedback; 7) Call onApprovalComplete callback after successful submission. Style with Tailwind CSS consistent with existing components (reference QueryForm.tsx and AgentCard.tsx patterns). Add optional realtime subscription to show if another user is also reviewing.",
            "status": "pending",
            "testStrategy": "Component tests for approve flow (button click ‚Üí action called ‚Üí success state). Component tests for reject flow with reason field. Test loading and error states. Verify accessibility (keyboard navigation, ARIA labels).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add approval status fields and integrate with content/research job updates",
            "description": "Extend the database schema with approval status fields and update content/research job flows to trigger and respond to approval events.",
            "dependencies": [
              1,
              3
            ],
            "details": "1) Update Prisma schema (prisma/schema.prisma): Add to ResearchContext model: approvalStatus (enum: 'draft', 'pending_approval', 'approved', 'rejected'), approvalRequestedAt (DateTime?), approvalDecidedAt (DateTime?), approvedBy (String?), rejectionReason (String?). Create new ContentItem model with same approval fields if not exists. 2) Run prisma migrate dev to apply changes. 3) Create approval channel in src/inngest/channels.ts with topics: 'approval-requested', 'approval-decided'. 4) Update content generation workflows to: emit 'approval.requested' event when content is ready for review; listen for 'content.approved'/'content.rejected' events to update status. 5) Create src/app/api/approval/pending/route.ts GET endpoint to list items pending approval for a user. 6) Add ApprovalQueue component showing all pending items with links to individual approval prompts.",
            "status": "pending",
            "testStrategy": "Database migration test verifying schema changes apply cleanly. Integration test for full flow: content generation ‚Üí approval requested ‚Üí pending list shows item ‚Üí approval decision ‚Üí status updated. Test realtime channel publishes approval state changes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down approval workflow into: 1) Creating approval-workflow.ts Inngest function with waitForEvent pattern (7-day timeout); 2) Creating /api/approval route to emit approval.response event; 3) Creating approval-prompt.tsx UI component with approve/reject buttons and reason field; 4) Adding approval event types and integrating with content/research job status updates. Inngest waitForEvent pattern is documented but new to this codebase."
      },
      {
        "id": "7",
        "title": "Implement Content Generation Phase 3 - Unified Writer",
        "description": "Create the unified content writer agent that generates multi-format content (blog posts, social captions, product descriptions) from research and context briefs per PRD Feature 3.1.",
        "details": "1. Create `src/inngest/functions/content-writer-agent.ts`:\n```typescript\nexport const contentWriterAgent = inngest.createFunction(\n  { id: 'content-writer-agent' },\n  { event: 'content.generation.requested' },\n  async ({ event, step, publish }) => {\n    const { contextBriefId, contentTypes, brandId, sessionId } = event.data;\n    \n    // Fetch context brief and brand\n    const [brief, brand] = await Promise.all([\n      step.run('fetch-brief', () => prisma.researchJob.findUnique({...})),\n      step.run('fetch-brand', () => prisma.brandConfig.findUnique({...}))\n    ]);\n    \n    // Generate content for each type in parallel\n    const contentResults = await Promise.all(\n      contentTypes.map(type => \n        step.run(`generate-${type}`, async () => {\n          const systemPrompt = buildSystemPrompt(brand, type);\n          const response = await anthropic.messages.create({\n            model: 'claude-3-5-sonnet-20241022',\n            system: systemPrompt,\n            messages: [{ role: 'user', content: buildContentPrompt(brief, type) }]\n          });\n          return { type, content: response.content[0].text };\n        })\n      )\n    );\n    \n    // Save drafts to database\n    const savedContent = await step.run('save-drafts', async () => {\n      return await Promise.all(\n        contentResults.map(r => \n          prisma.contentItem.create({\n            data: {\n              researchJobId: contextBriefId,\n              contentType: r.type,\n              copy: r.content,\n              status: 'draft',\n              platform: mapTypeToPlatform(r.type)\n            }\n          })\n        )\n      );\n    });\n    \n    // Request approval\n    await step.sendEvent('request-approval', {\n      name: 'approval.requested',\n      data: { itemId: savedContent[0].id, itemType: 'content' }\n    });\n    \n    return { drafts: savedContent };\n  }\n);\n```\n\n2. Create content type definitions in `src/types/content.ts`\n\n3. Create Content Generation page with:\n- Content type selection (blog, twitter, linkedin, instagram)\n- Preview of generated content\n- Edit capability before approval\n- Approval/reject buttons",
        "testStrategy": "Unit tests for prompt building functions. Integration tests verifying content is saved to database. Test parallel generation of multiple content types. Verify brand voice is applied correctly.",
        "priority": "medium",
        "dependencies": [
          "1",
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down content writer agent into: 1) Creating content-writer-agent.ts main function with content generation logic; 2) Creating prompt building utilities for different content types (blog, twitter, linkedin, instagram); 3) Creating content type definitions in types/content.ts; 4) Implementing parallel content generation for multiple types using existing fan-out pattern; 5) Creating Content Generation page with type selection, preview, and edit capability. Reuse ai SDK patterns from existing agents."
      },
      {
        "id": "8",
        "title": "Implement Canva MCP Integration for Design Generation",
        "description": "Integrate Canva MCP server for automated design creation aligned with brand guidelines per PRD Feature 3.2, using AgentKit Pattern 6.",
        "details": "1. Create MCP client for Canva at `src/lib/mcp/canva-client.ts`:\n```typescript\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\n\nexport class CanvaMCPClient {\n  private client: Client;\n  \n  async createDesign(params: {\n    copy: string;\n    brandColors: { primary: string; secondary: string };\n    logoUrl?: string;\n    designType: 'social_post' | 'carousel' | 'banner';\n  }) {\n    const result = await this.client.callTool({\n      name: 'create_design',\n      arguments: params\n    });\n    return result;\n  }\n  \n  async applyBrandKit(designId: string, brandId: string) {\n    // Apply brand colors, fonts, logo\n  }\n}\n```\n\n2. Create `src/inngest/functions/canva-agent.ts`:\n```typescript\nexport const canvaDesignAgent = inngest.createFunction(\n  { id: 'canva-design-agent' },\n  { event: 'content.design.requested' },\n  async ({ event, step }) => {\n    const { contentItemId, brandId } = event.data;\n    \n    const [content, brand] = await Promise.all([\n      step.run('fetch-content', () => prisma.contentItem.findUnique({...})),\n      step.run('fetch-brand', () => prisma.brandConfig.findUnique({...}))\n    ]);\n    \n    const design = await step.run('create-design', async () => {\n      const canva = new CanvaMCPClient();\n      return await canva.createDesign({\n        copy: content.copy,\n        brandColors: brand.brandColors,\n        logoUrl: brand.logoUrl,\n        designType: mapContentTypeToDesign(content.contentType)\n      });\n    });\n    \n    // Update content item with design assets\n    await step.run('save-design', async () => {\n      await prisma.contentItem.update({\n        where: { id: contentItemId },\n        data: { designAssets: design }\n      });\n    });\n    \n    return design;\n  }\n);\n```\n\n3. Add Canva environment variables to `.env.example`:\n- CANVA_API_KEY\n- CANVA_API_SECRET\n\n4. Update Content tab UI to show design previews alongside copy",
        "testStrategy": "Mock Canva MCP responses for unit tests. Integration test with actual Canva API in sandbox environment. Verify design assets are correctly stored and retrievable.",
        "priority": "medium",
        "dependencies": [
          "3",
          "7"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down Canva MCP integration into: 1) Creating MCP client wrapper for Canva at lib/mcp/canva-client.ts with design creation methods; 2) Creating canva-agent.ts Inngest function to orchestrate design generation; 3) Integrating brand colors and logo from BrandConfig into design requests; 4) Updating Content tab UI to show design previews alongside copy with proper error handling. This is greenfield MCP integration."
      },
      {
        "id": "9",
        "title": "Implement Multi-Channel Publishing Agents",
        "description": "Create individual publisher agents for Shopify, Twitter, LinkedIn, and Instagram with platform-specific API integrations per PRD Feature 4.1.",
        "details": "1. Create platform-specific publisher agents:\n\n`src/inngest/functions/publishers/shopify-publisher.ts`:\n```typescript\nexport const shopifyPublisher = inngest.createFunction(\n  { id: 'shopify-publisher' },\n  { event: 'publishing.shopify.requested' },\n  async ({ event, step }) => {\n    const { contentItemId } = event.data;\n    \n    const content = await step.run('fetch-content', () => \n      prisma.contentItem.findUnique({ where: { id: contentItemId } })\n    );\n    \n    const result = await step.run('publish-to-shopify', async () => {\n      const shopify = new ShopifyClient({\n        storeUrl: process.env.SHOPIFY_STORE_URL,\n        accessToken: process.env.SHOPIFY_ACCESS_TOKEN\n      });\n      \n      if (content.contentType === 'blog_post') {\n        return await shopify.blog.createArticle({...});\n      } else {\n        return await shopify.products.update({...});\n      }\n    });\n    \n    return result;\n  }\n);\n```\n\n2. Create `src/inngest/functions/publishers/social-publisher.ts` for Twitter/LinkedIn/Instagram\n\n3. Create API client wrappers in `src/lib/api-clients/`:\n- `shopify.ts` - Shopify Admin API\n- `twitter.ts` - Twitter API v2\n- `linkedin.ts` - LinkedIn Marketing API\n- `instagram.ts` - Instagram Graph API (via Meta)\n\n4. Add all required API keys to `.env.example`\n\n5. Create Publishing page showing:\n- All approved content ready for publishing\n- Platform selection checkboxes\n- Schedule date picker\n- Publish button",
        "testStrategy": "Mock all external APIs for unit tests. Integration tests using sandbox/test accounts for each platform. Verify error handling for API rate limits and failures.",
        "priority": "medium",
        "dependencies": [
          "1",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down multi-channel publishing into: 1) Creating shopify-publisher.ts agent with Shopify Admin API integration; 2) Creating twitter-publisher.ts agent with Twitter API v2; 3) Creating linkedin-publisher.ts agent with LinkedIn Marketing API; 4) Creating instagram-publisher.ts agent with Instagram Graph API; 5) Creating API client wrappers in lib/api-clients/ for each platform; 6) Creating Publishing page with platform selection, scheduling, and status display. Each platform has unique API requirements."
      },
      {
        "id": "10",
        "title": "Implement Publishing Queue Manager with Retry Logic",
        "description": "Create the queue manager for publishing jobs with exponential backoff retry logic, job status tracking, and audit logging per PRD Feature 4.2.",
        "details": "1. Create `src/inngest/functions/queue-manager.ts`:\n```typescript\nexport const publishingQueueManager = inngest.createFunction(\n  {\n    id: 'publishing-queue-manager',\n    retries: 3,\n    backoff: { type: 'exponential', base: '30s', maxDelay: '1h' }\n  },\n  { event: 'publishing.scheduled' },\n  async ({ event, step, attempt }) => {\n    const { contentItemId, platforms, scheduledAt } = event.data;\n    \n    // Wait until scheduled time if in future\n    if (scheduledAt && new Date(scheduledAt) > new Date()) {\n      await step.sleepUntil('wait-for-schedule', new Date(scheduledAt));\n    }\n    \n    // Create queue entries\n    const queueEntries = await step.run('create-queue-entries', async () => {\n      return await Promise.all(\n        platforms.map(platform =>\n          prisma.publishingQueue.create({\n            data: {\n              contentItemId,\n              platform,\n              scheduledAt,\n              status: 'pending'\n            }\n          })\n        )\n      );\n    });\n    \n    // Publish to each platform (with individual error handling)\n    const results = await Promise.allSettled(\n      platforms.map(platform =>\n        step.invoke(`publish-${platform}`, {\n          function: getPublisherFunction(platform),\n          data: { contentItemId }\n        })\n      )\n    );\n    \n    // Update queue statuses\n    await step.run('update-statuses', async () => {\n      for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n        await prisma.publishingQueue.update({\n          where: { id: queueEntries[i].id },\n          data: {\n            status: result.status === 'fulfilled' ? 'published' : 'failed',\n            publishedAt: result.status === 'fulfilled' ? new Date() : null,\n            errorLog: result.status === 'rejected' ? String(result.reason) : null,\n            retryCount: attempt\n          }\n        });\n      }\n    });\n    \n    // Log to audit\n    await step.run('audit-log', async () => {\n      await prisma.agentAuditLog.create({\n        data: {\n          agentName: 'queue-manager',\n          action: 'publish',\n          jobId: contentItemId,\n          status: results.every(r => r.status === 'fulfilled') ? 'success' : 'partial',\n          metadata: { platforms, results: results.map(r => r.status) }\n        }\n      });\n    });\n    \n    return { results };\n  }\n);\n```\n\n2. Create scheduled cron function for queue processing:\n```typescript\nexport const queueProcessor = inngest.createFunction(\n  { id: 'queue-processor' },\n  { cron: '0 * * * *' }, // Every hour\n  async ({ step }) => {\n    // Find failed jobs eligible for retry\n    const failedJobs = await step.run('find-failed', async () => {\n      return await prisma.publishingQueue.findMany({\n        where: { status: 'failed', retryCount: { lt: 3 } }\n      });\n    });\n    \n    // Re-queue each for retry\n    for (const job of failedJobs) {\n      await step.sendEvent(`retry-${job.id}`, {\n        name: 'publishing.scheduled',\n        data: { contentItemId: job.contentItemId, platforms: [job.platform] }\n      });\n    }\n  }\n);\n```\n\n3. Update Publishing page to show queue status, retry counts, and error logs",
        "testStrategy": "Unit tests for retry logic with various failure scenarios. Integration tests simulating rate limits and temporary failures. Verify exponential backoff timing is correct. Test audit log accuracy.",
        "priority": "medium",
        "dependencies": [
          "1",
          "9"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down queue manager into: 1) Creating queue-manager.ts with exponential backoff retry configuration and scheduled execution; 2) Creating cron-based queue-processor.ts for failed job retry; 3) Implementing audit logging to AgentAuditLog table; 4) Updating Publishing page to show queue status, retry counts, and error logs. Inngest has built-in retry/backoff but requires proper configuration."
      },
      {
        "id": "11",
        "title": "Create TypeScript Types and Event Definitions",
        "description": "Consolidate all TypeScript type definitions for research, brand, content, and publishing domains, and define complete Inngest event schemas.",
        "details": "1. Create type definitions in `src/types/`:\n\n`src/types/research.ts`:\n```typescript\nexport interface DeepResearchReport {\n  topic: string;\n  summary: string;\n  findings: Array<{\n    title: string;\n    content: string;\n    sources: string[];\n    confidence: number;\n  }>;\n  citations: Array<{\n    id: number;\n    source: string;\n    url: string;\n    title: string;\n  }>;\n  metadata: {\n    depth: number;\n    breadth: number;\n    sourcesSearched: number;\n    completedAt: string;\n  };\n}\n\nexport interface ContextBrief {\n  themes: string[];\n  opportunities: string[];\n  warnings: string[];\n  brandAlignment: {\n    tovMatch: number;\n    keywordCoverage: string[];\n    suggestions: string[];\n  };\n}\n```\n\n`src/types/content.ts`:\n```typescript\nexport type ContentType = 'blog_post' | 'social_post' | 'carousel' | 'product_description';\nexport type Platform = 'blog' | 'twitter' | 'linkedin' | 'instagram' | 'shopify';\nexport type ContentStatus = 'draft' | 'pending_approval' | 'approved' | 'rejected' | 'published';\n\nexport interface ContentDraft {\n  id: string;\n  type: ContentType;\n  copy: string;\n  designAssets?: {\n    canvaUrl?: string;\n    images?: string[];\n  };\n  status: ContentStatus;\n  platform: Platform;\n}\n```\n\n2. Update `src/inngest/client.ts` with complete event schemas:\n```typescript\nexport const inngest = new Inngest({\n  id: 'research-publishing-suite',\n  schemas: new EventSchemas().fromRecord<{\n    'deep.research.requested': { data: DeepResearchRequest };\n    'deep.research.completed': { data: DeepResearchCompleted };\n    'context.research.requested': { data: ContextResearchRequest };\n    'context.research.completed': { data: ContextResearchCompleted };\n    'content.generation.requested': { data: ContentGenerationRequest };\n    'content.generated': { data: ContentGeneratedEvent };\n    'content.design.requested': { data: DesignRequest };\n    'approval.requested': { data: ApprovalRequest };\n    'approval.response': { data: ApprovalResponse };\n    'publishing.scheduled': { data: PublishingScheduled };\n    'publishing.completed': { data: PublishingCompleted };\n  }>()\n});\n```\n\n3. Create barrel exports at `src/types/index.ts`",
        "testStrategy": "TypeScript compilation should catch type errors. Create type guard functions and test them with valid/invalid data. Ensure all Inngest event handlers match their schemas.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down TypeScript types task into: 1) Creating types/research.ts with DeepResearchReport, ContextBrief interfaces; 2) Creating types/content.ts with ContentType, Platform, ContentStatus, ContentDraft types; 3) Updating inngest/client.ts with complete event schemas for all events (deep, context, content, approval, publishing). Existing types.ts and channels.ts provide patterns."
      },
      {
        "id": "12",
        "title": "Configure Testing Infrastructure with Jest and Playwright",
        "description": "Set up complete testing infrastructure including Jest for unit/integration tests and Playwright for E2E tests, with proper mocking patterns for external APIs.",
        "details": "1. Update `jest.config.js` for proper path aliases and coverage:\n```javascript\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'jsdom',\n  moduleNameMapper: {\n    '^@/(.*)$': '<rootDir>/src/$1'\n  },\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  collectCoverageFrom: [\n    'src/**/*.{ts,tsx}',\n    '!src/**/*.d.ts',\n    '!src/types/**/*'\n  ],\n  coverageThreshold: {\n    global: { branches: 70, functions: 80, lines: 80, statements: 80 },\n    './src/inngest/**/*.ts': { branches: 85, functions: 90, lines: 90 }\n  }\n};\n```\n\n2. Create test utilities at `tests/setup/`:\n- `mock-prisma.ts` - Prisma client mock factory\n- `mock-inngest.ts` - Inngest function testing utilities\n- `mock-apis.ts` - External API mocks (Anthropic, Shopify, Twitter, etc.)\n\n3. Create test fixtures at `tests/fixtures/`:\n- `brands.ts` - Sample brand configurations\n- `research.ts` - Sample research reports\n- `content.ts` - Sample content items\n\n4. Update `playwright.config.ts` for E2E tests:\n```typescript\nexport default defineConfig({\n  testDir: './e2e',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry'\n  },\n  webServer: {\n    command: 'npm run dev',\n    port: 3000,\n    reuseExistingServer: !process.env.CI\n  }\n});\n```\n\n5. Add npm scripts:\n```json\n\"test:unit\": \"jest --testPathPattern=unit\",\n\"test:integration\": \"jest --testPathPattern=integration\",\n\"test:e2e\": \"playwright test\",\n\"test:all\": \"npm run test:unit && npm run test:integration && npm run test:e2e\"\n```",
        "testStrategy": "Meta-testing: Verify mock utilities work correctly. Run test suite to ensure all configurations are valid. Check coverage reports generate properly.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down testing infrastructure into: 1) Updating jest.config.js with path aliases, coverage thresholds for inngest functions; 2) Creating test utilities at tests/setup/ for mock-prisma.ts, mock-inngest.ts, mock-apis.ts; 3) Creating test fixtures at tests/fixtures/ for brands, research, content; 4) Updating playwright.config.ts with webServer configuration. package.json already has Jest/Playwright dependencies."
      },
      {
        "id": "13",
        "title": "Implement Native Inngest Realtime Streaming",
        "description": "Implement streaming updates using the native `@inngest/realtime` package across all 4 phases (Deep, Context, Content, Publishing) with unified progress tracking, replacing custom implementations.",
        "details": "1. Install and configure `@inngest/realtime`:\n   - Install: `npm install @inngest/realtime`\n   - Add `realtimeMiddleware()` to Inngest client in `src/inngest/client.ts`\n\n2. Extend `src/inngest/channels.ts` using the new typed channel builder:\n```typescript\nimport { channel, topic } from '@inngest/realtime';\n\nexport const researchChannel = channel('research')\n  .addTopic(topic('deep-progress').schema(z.object({\n    stage: z.enum(['staging', 'reasoning', 'reporting']),\n    progress: z.number(),\n    message: z.string(),\n    timestamp: z.string()\n  })))\n  .addTopic(topic('context-progress').schema(z.object({...})));\n  // Add content and publishing topics\n```\n\n3. Implement server-side token generation:\n   - Create `src/actions.ts` server action: `fetchSubscriptionToken(channelId)`\n   - Use `getSubscriptionToken(inngest, { channel: ..., topics: [...] })`\n\n4. Update `src/components/phase-progress.tsx` to use the native hook:\n```tsx\nimport { useInngestSubscription } from '@inngest/realtime/hooks';\n\nexport function PhaseProgress({ sessionId }) {\n  const { data, latestData, state } = useInngestSubscription({\n    refreshToken: () => fetchSubscriptionToken(sessionId)\n  });\n  // Render UI based on typed data\n}\n```\n\n5. Update agents to use `publish` from context:\n   - `async ({ event, step, publish }) => { ... await publish(researchChannel.deepProgress({...})) }`",
        "testStrategy": "Component tests for progress rendering with various states using mocked subscription hook. Integration tests verifying realtime updates are received correctly. E2E test watching full workflow progress from start to finish.",
        "priority": "medium",
        "dependencies": [
          "2",
          "4",
          "5",
          "7",
          "9"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down realtime streaming into: 1) Installing @inngest/realtime and configuring middleware; 2) Defining typed channels in channels.ts with Zod schemas; 3) Implementing server actions for token generation; 4) Creating unified phase-progress.tsx component using useInngestSubscription hook; 5) Updating agents to use the publish function."
      },
      {
        "id": "14",
        "title": "Create API Routes for Research and Project Management",
        "description": "Implement REST API routes for research job management, project lifecycle, and status endpoints as specified in the PRD structural decomposition.",
        "details": "1. Create `src/app/api/research/route.ts`:\n```typescript\n// GET - List research jobs with filtering\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const status = searchParams.get('status');\n  const tabType = searchParams.get('tabType');\n  \n  const jobs = await prisma.researchJob.findMany({\n    where: {\n      ...(status && { status }),\n      ...(tabType && { tabType })\n    },\n    orderBy: { createdAt: 'desc' },\n    take: 50\n  });\n  \n  return Response.json(jobs);\n}\n\n// POST - Create new research job\nexport async function POST(request: Request) {\n  const body = await request.json();\n  \n  const job = await prisma.researchJob.create({\n    data: {\n      topic: body.topic,\n      tabType: body.tabType,\n      parameters: body.parameters,\n      status: 'pending',\n      createdBy: body.userId\n    }\n  });\n  \n  // Trigger appropriate Inngest event based on tabType\n  await inngest.send({\n    name: `${body.tabType}.research.requested`,\n    data: { jobId: job.id, ...body }\n  });\n  \n  return Response.json(job);\n}\n```\n\n2. Create `src/app/api/research/[id]/route.ts` for GET/PUT/DELETE\n\n3. Create `src/app/api/research/[id]/status/route.ts` for status polling\n\n4. Create `src/app/api/project/route.ts` for project CRUD:\n```typescript\n// Project management endpoints\n// - Create project with brand association\n// - List projects with phase completion tracking\n// - Archive completed projects\n```\n\n5. Create `src/app/api/content/route.ts` for content item management\n\n6. Create `src/app/api/publishing/route.ts` for publishing queue management",
        "testStrategy": "Unit tests for each API route using mocked database. Integration tests verifying API ‚Üí Inngest event triggering. Test error handling and validation for invalid inputs.",
        "priority": "medium",
        "dependencies": [
          "1",
          "11"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down API routes into: 1) Creating /api/research routes for CRUD operations with filtering by status/tabType; 2) Creating /api/research/[id] and /api/research/[id]/status routes; 3) Creating /api/project routes for project CRUD with brand association; 4) Creating /api/content and /api/publishing routes for content and queue management. Follow existing api/inngest/route.ts patterns."
      },
      {
        "id": "15",
        "title": "Finalize GitHub Actions CI/CD Pipeline",
        "description": "Complete the CI/CD configuration with parallel test execution, coverage reporting, and automated deployment to Vercel/Cloud Run.",
        "details": "1. Create `.github/workflows/ci.yml`:\n```yaml\nname: CI\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run type-check\n\n  test-unit:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run test:unit -- --coverage\n      - uses: codecov/codecov-action@v3\n\n  test-integration:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: test\n        ports:\n          - 5432:5432\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n      - run: npm ci\n      - run: npm run test:integration\n\n  test-e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n      - run: npm ci\n      - run: npx playwright install --with-deps\n      - run: npm run test:e2e\n```\n\n2. Create `.github/workflows/deploy.yml`:\n```yaml\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy-vercel:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: amondnet/vercel-action@v25\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}\n          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}\n          vercel-args: '--prod'\n```\n\n3. Add status badges to README.md\n\n4. Configure branch protection rules requiring CI to pass",
        "testStrategy": "Verify CI runs successfully on a test PR. Confirm coverage reports upload to Codecov. Test deployment to staging environment before main merge.",
        "priority": "low",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down CI/CD pipeline into: 1) Creating .github/workflows/ci.yml with parallel lint, test-unit, test-integration, test-e2e jobs; 2) Creating .github/workflows/deploy.yml with Vercel deployment action; 3) Adding status badges to README and configuring branch protection. .github/instructions/ directory exists but no workflows yet."
      },
      {
        "id": "16",
        "title": "Create MCP Client Infrastructure",
        "description": "Create the MCP client infrastructure with support for Jina.AI, Firecrawl, Reddit, and Google Deep Research integrations following AgentKit patterns.",
        "details": "Create `/src/lib/mcp/` directory with the following files:\n\n1. `types.ts` - Define MCPSource type ('jina' | 'firecrawl' | 'reddit' | 'google_deep_research' | 'vectordb'), MCPResult interface, MCPConfig interface for transport configuration.\n\n2. `jina-client.ts` - SSE transport client for Jina.AI MCP:\n   - URL: https://mcp.jina.ai/v1?include_tags=search,read\n   - Tools: search_web, read_url, parallel_search_web\n   - Requires JINA_API_KEY\n\n3. `firecrawl-client.ts` - SSE transport client for Firecrawl MCP:\n   - URL: https://mcp.firecrawl.dev/v2/mcp\n   - Tools: firecrawl_scrape, firecrawl_search, firecrawl_crawl, firecrawl_extract\n   - Requires FIRECRAWL_API_KEY\n\n4. `reddit-client.ts` - stdio transport client for Reddit MCP:\n   - Command: uvx mcp-server-reddit\n   - Tools: get_frontpage_posts, get_subreddit_info, get_subreddit_hot_posts, get_subreddit_new_posts, get_subreddit_top_posts, get_subreddit_rising_posts, get_post_content, get_post_comments\n   - NO credentials required!\n\n5. `google-deep-research.ts` - Custom wrapper for Google Interactions API:\n   - Uses GoogleGenerativeAI SDK\n   - Agent: deep-research-pro-preview-12-2025\n   - Implements polling for async results\n   - Cost tracking (~$2-5 per query)\n\n6. `mcp-router.ts` - Routes queries to selected MCPs with Promise.allSettled\n\n7. `index.ts` - Barrel exports",
        "testStrategy": "Unit tests for each MCP client with mocked responses. Integration tests for Reddit MCP (no credentials needed). Test error handling and retry logic.",
        "priority": "high",
        "dependencies": ["1"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MCP types and interfaces",
            "description": "Create `/src/lib/mcp/types.ts` with MCPSource, MCPResult, MCPConfig, and transport type definitions.",
            "dependencies": [],
            "details": "Define TypeScript types for the MCP infrastructure including MCPSource union type, MCPResult interface with source attribution, MCPConfig for transport settings, and helper types for each MCP's specific response formats.",
            "status": "pending",
            "testStrategy": "TypeScript compilation check"
          },
          {
            "id": 2,
            "title": "Create Jina MCP client",
            "description": "Implement SSE transport client for Jina.AI with search_web and read_url methods.",
            "dependencies": [1],
            "details": "Use SSE transport with authorization header. Implement searchWeb(query, options) and readUrl(url) methods. Handle rate limiting and errors.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked SSE responses"
          },
          {
            "id": 3,
            "title": "Create Firecrawl MCP client",
            "description": "Implement SSE transport client for Firecrawl with scrape, search, and crawl methods.",
            "dependencies": [1],
            "details": "Use SSE transport with authorization header. Implement scrape(url), search(query), crawl(url, depth) methods.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked SSE responses"
          },
          {
            "id": 4,
            "title": "Create Reddit MCP client",
            "description": "Implement stdio transport client for Reddit MCP using uvx mcp-server-reddit.",
            "dependencies": [1],
            "details": "Use stdio transport with uvx command. Implement methods for all 8 Reddit tools. No credentials required.",
            "status": "pending",
            "testStrategy": "Integration tests with actual Reddit MCP"
          },
          {
            "id": 5,
            "title": "Create Google Deep Research wrapper",
            "description": "Implement custom wrapper for Google Interactions API with polling support.",
            "dependencies": [1],
            "details": "Use GoogleGenerativeAI SDK. Implement executeDeepResearch(query) with background: true and polling. Track cost per query.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked API responses"
          },
          {
            "id": 6,
            "title": "Create MCP router",
            "description": "Implement router that dispatches queries to selected MCPs in parallel.",
            "dependencies": [2, 3, 4, 5],
            "details": "Use Promise.allSettled for parallel execution. Normalize results to ContextItem interface. Add source diversity bonus for ranking.",
            "status": "pending",
            "testStrategy": "Integration tests with multiple MCPs"
          },
          {
            "id": 7,
            "title": "Create barrel exports",
            "description": "Create index.ts with all exports from the mcp module.",
            "dependencies": [6],
            "details": "Export all types, clients, and router from /src/lib/mcp/index.ts",
            "status": "pending",
            "testStrategy": "Import verification"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down MCP client infrastructure into types definition, individual client implementations for each MCP, router, and exports."
      },
      {
        "id": "17",
        "title": "Implement Reddit MCP Integration with Workflow",
        "description": "Create the Reddit-specific research workflow with subreddit mapping, multi-subreddit parallel fetch, and comment depth fetching.",
        "details": "Implement a sophisticated Reddit research workflow:\n\n1. Create subreddit mapping per query type in `/src/lib/mcp/reddit-workflow.ts`:\n   - Tech/AI: r/MachineLearning, r/artificial, r/LocalLLaMA, r/singularity\n   - Marketing: r/marketing, r/socialmedia, r/Entrepreneur\n   - Product feedback: r/[product], r/reviews\n   - Industry news: r/technology, r/business, r/startups\n\n2. Implement `fetchReddit(query, options)` workflow:\n   - Step 1: identifySubreddits(query) - Use NLP/keywords to find relevant subreddits\n   - Step 2: Parallel fetch top posts from each subreddit (limit: 10, time_filter: month)\n   - Step 3: Select top 5 posts and fetch comments (depth: 3, limit: 20)\n   - Step 4: Normalize to ContextItem with Reddit-specific metadata\n\n3. Add Reddit-specific realtime progress updates:\n   - 'reddit-subreddits-found' topic\n   - 'reddit-posts-fetched' topic\n   - 'reddit-comments-fetched' topic\n\n4. Handle Reddit's unique data (upvotes, awards, comment threads) for ranking",
        "testStrategy": "Integration tests with actual Reddit MCP for various query types. Verify subreddit mapping accuracy. Test comment depth handling.",
        "priority": "high",
        "dependencies": ["16"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create subreddit mapping configuration",
            "description": "Define keyword-to-subreddit mappings for different query types.",
            "dependencies": [],
            "details": "Create configurable mapping with categories and fallback subreddits.",
            "status": "pending",
            "testStrategy": "Unit tests for mapping logic"
          },
          {
            "id": 2,
            "title": "Implement fetchReddit workflow",
            "description": "Create the main Reddit fetch workflow with parallel subreddit queries.",
            "dependencies": [1],
            "details": "Use Promise.allSettled for parallel subreddit fetching. Select top posts and fetch comments.",
            "status": "pending",
            "testStrategy": "Integration tests with Reddit MCP"
          },
          {
            "id": 3,
            "title": "Add Reddit-specific realtime updates",
            "description": "Create realtime channel topics for Reddit progress tracking.",
            "dependencies": [2],
            "details": "Add topics to channels.ts for Reddit-specific progress updates.",
            "status": "pending",
            "testStrategy": "Verify realtime updates stream correctly"
          },
          {
            "id": 4,
            "title": "Normalize Reddit results to ContextItem",
            "description": "Transform Reddit API responses to standard ContextItem format.",
            "dependencies": [2],
            "details": "Include upvotes, awards, comment count in metadata. Handle nested comment threads.",
            "status": "pending",
            "testStrategy": "Unit tests for normalization"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down Reddit workflow into subreddit mapping, fetch implementation, realtime updates, and result normalization."
      },
      {
        "id": "18",
        "title": "Replace Old Source Files with MCP Sources",
        "description": "Create new source wrapper files for each MCP and archive the old ArXiv/GitHub sources.",
        "details": "Create wrapper files in `/src/lib/sources/` that use the MCP clients:\n\n1. `jina.ts` - Wrapper around Jina MCP client:\n   - Export fetchJina(query) function\n   - Normalize results to ContextItem\n   - Handle errors gracefully\n\n2. `firecrawl.ts` - Wrapper around Firecrawl MCP client:\n   - Export fetchFirecrawl(query) function\n   - Use scrape for URLs, search for queries\n   - Normalize results to ContextItem\n\n3. `reddit.ts` - Wrapper around Reddit workflow:\n   - Export fetchReddit(query) function\n   - Uses reddit-workflow.ts\n   - Normalize results to ContextItem\n\n4. `google-deep-research.ts` - Wrapper around Google DR:\n   - Export fetchGoogleDeepResearch(query) function\n   - Handle async polling internally\n   - Normalize results to ContextItem\n\n5. Update `index.ts` with new exports\n\n6. Archive (rename to .archived) arxiv.ts and github.ts for reference",
        "testStrategy": "Unit tests for each wrapper. Integration tests verifying ContextItem normalization.",
        "priority": "high",
        "dependencies": ["16", "17"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into creating each source wrapper file and archiving old sources."
      },
      {
        "id": "19",
        "title": "Update gather-context for Dynamic MCP Selection",
        "description": "Modify gather-context.ts to accept selectedMCPs array and route to MCP router instead of hardcoded sources.",
        "details": "Update `/src/inngest/functions/gather-context.ts`:\n\n1. Update event type in client.ts to include selectedMCPs: string[] in 'research/gather-context' event data\n\n2. Modify gatherContext function:\n   - Accept selectedMCPs from event.data (default: ['jina', 'reddit'])\n   - Replace hardcoded source calls with MCP router\n   - Keep VectorDB always active\n\n3. Update source-result publishing:\n   - Dynamically publish for each selected MCP\n   - Use MCP name as source identifier\n\n4. Add fallback logic:\n   - If all MCPs fail, fall back to VectorDB only\n   - Publish error with recoverable: true\n\n5. Update progress messages to reflect dynamic sources\n\n6. Update tests to cover new MCP selection behavior",
        "testStrategy": "Integration tests with various MCP combinations. Test fallback behavior. Verify realtime updates for each MCP.",
        "priority": "high",
        "dependencies": ["18"],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into event schema update, gather-context modification, source-result publishing, fallback logic, and testing."
      },
      {
        "id": "20",
        "title": "Add Database Models for Preferences and Credentials",
        "description": "Add UserPreferences and APICredential models to Prisma schema with encryption support for storing user API keys.",
        "details": "Update `/prisma/schema.prisma` and create supporting files:\n\n1. Add UserPreferences model:\n   - id, createdAt, updatedAt, userId (unique)\n   - defaultMCPs: String[] @default([\"jina\", \"reddit\"])\n   - mcpPriority: String[]\n   - defaultDepth, defaultBreadth: Int\n   - showAdvancedOptions: Boolean\n   - relation to APICredential[]\n\n2. Add APICredential model:\n   - id, createdAt, updatedAt\n   - userPrefsId (FK), service, credentialType\n   - encryptedValue: String\n   - isValid: Boolean, lastValidated: DateTime?\n   - @@unique([userPrefsId, service])\n\n3. Update ResearchJob model:\n   - Add mcpsUsed: String[] @default([])\n   - Add mcpResults: Json?\n\n4. Create `/src/lib/credentials.ts`:\n   - encryptCredential(value) using AES-256-CBC\n   - decryptCredential(encrypted)\n   - Uses CREDENTIALS_ENCRYPTION_KEY env var\n\n5. Run `npx prisma db push` (in Codespace)\n\n6. Create type exports in `/src/types/preferences.ts`",
        "testStrategy": "Database migration test. Unit tests for encrypt/decrypt functions. Integration tests for CRUD operations.",
        "priority": "high",
        "dependencies": ["1"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into Prisma schema updates, credentials utility, migration, and type exports."
      },
      {
        "id": "21",
        "title": "Create MCPSelector Component",
        "description": "Create a reusable MCPSelector component for selecting 1-4 research sources with status indicators.",
        "details": "Create `/src/components/MCPSelector.tsx`:\n\n1. Props interface:\n   - selectedMCPs: string[]\n   - onChange: (mcps: string[]) => void\n   - maxSelections?: number (default 4)\n   - disabled?: boolean\n   - credentialStatus?: Record<string, 'connected' | 'not_configured' | 'no_auth_needed'>\n\n2. MCP options configuration:\n   - jina: name='Jina.AI', icon='üîç', description='Web search & content reading'\n   - firecrawl: name='Firecrawl', icon='üî•', description='Advanced web scraping'\n   - reddit: name='Reddit', icon='üí¨', description='Community insights', noAuthNeeded=true\n   - google_deep_research: name='Google Deep', icon='üß†', description='AI deep research', costWarning='$2-5/query'\n\n3. UI features:\n   - Checkbox multi-select with validation (min 1, max 4)\n   - Status indicators per MCP (checkmark, gear, free badge)\n   - Tooltips with descriptions and cost warnings\n   - Disable unconfigured MCPs (except Reddit)\n\n4. Styling:\n   - Dark theme: bg-slate-800, border-slate-700, text-white\n   - Selected: bg-indigo-600/20, border-indigo-500\n   - Disabled: opacity-50, cursor-not-allowed",
        "testStrategy": "Component tests for selection logic. Accessibility tests. Visual regression tests for status indicators.",
        "priority": "medium",
        "dependencies": ["20"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into props definition, MCP config, selection logic, status indicators, and styling."
      },
      {
        "id": "22",
        "title": "Update QueryForm with MCP Selection",
        "description": "Integrate MCPSelector into QueryForm with collapsible Advanced Options section.",
        "details": "Update `/src/components/QueryForm.tsx`:\n\n1. Add new state:\n   - selectedMCPs: string[] (default from user preferences)\n   - showAdvanced: boolean\n\n2. Add Advanced Options toggle:\n   - Collapsible section below query input\n   - Toggle button: 'Show/Hide Research Sources'\n\n3. Integrate MCPSelector:\n   - Pass selectedMCPs and onChange handler\n   - Pass credentialStatus from user preferences\n\n4. Update QueryFormProps:\n   - Add defaultMCPs?: string[]\n   - Update onSubmit: (query: string, selectedMCPs: string[]) => void\n\n5. Add info text:\n   - 'Configure missing credentials in Settings' link\n   - Show selected MCPs count in collapsed state\n\n6. Handle disabled state:\n   - Disable MCPSelector when loading\n   - Prevent form submission if no MCPs selected",
        "testStrategy": "Component tests for form behavior. Test MCP selection persistence. Test disabled states.",
        "priority": "medium",
        "dependencies": ["21"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into state management, Advanced Options UI, MCPSelector integration, and form updates."
      },
      {
        "id": "23",
        "title": "Create Settings Page with Credentials Management",
        "description": "Create the Settings page with API credentials management, MCP status, and research defaults.",
        "details": "Create Settings page and components:\n\n1. `/src/app/(dashboard)/settings/page.tsx`:\n   - Server component wrapper\n   - Sections: Research Credentials, Default Settings, Publishing Credentials\n\n2. `/src/components/settings/APICredentialsForm.tsx`:\n   - Form for each MCP (Jina, Firecrawl, Google)\n   - Password input with reveal toggle\n   - Test connection button\n   - Save/Update buttons\n   - Status indicator (connected/not configured)\n   - Help link to get API key\n\n3. `/src/components/settings/MCPStatusIndicator.tsx`:\n   - Shows connection status with icon\n   - Green checkmark = connected\n   - Red X = not configured\n   - Blue info = no auth needed (Reddit)\n\n4. `/src/components/settings/ResearchDefaultsForm.tsx`:\n   - Default MCPs selection (using MCPSelector)\n   - Default depth/breadth sliders\n   - Save preferences button\n\n5. Update `/src/components/sidebar.tsx`:\n   - Add Settings link with gear icon\n   - Route: /settings\n\n6. `/src/app/api/credentials/route.ts`:\n   - POST: Save encrypted credential\n   - GET: Get credential status (not decrypted value)\n   - PUT: Update credential\n   - DELETE: Remove credential\n   - POST /test: Test credential validity\n\n7. `/src/app/api/user-preferences/route.ts`:\n   - GET: Get user preferences\n   - PUT: Update user preferences",
        "testStrategy": "Component tests for forms. Integration tests for API routes. E2E test for full settings flow.",
        "priority": "high",
        "dependencies": ["20", "21"],
        "status": "pending",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down into page creation, form components, API routes, sidebar update, and credential testing."
      },
      {
        "id": "24",
        "title": "Update Actions and Orchestrator",
        "description": "Update server actions and orchestrator to pass selectedMCPs through the research pipeline.",
        "details": "Update server actions and Inngest functions:\n\n1. Update `/src/app/actions.ts`:\n   - Modify submitResearchQuery(query, sessionId, selectedMCPs?)\n   - Load user preferences if selectedMCPs not provided\n   - Load user credentials for selected MCPs\n   - Pass to Inngest event\n\n2. Update `/src/inngest/client.ts` event schemas:\n   - Add selectedMCPs: string[] to 'research/query.submitted'\n   - Add selectedMCPs: string[] to 'research/gather-context'\n\n3. Update `/src/inngest/functions/orchestrator.ts`:\n   - Extract selectedMCPs from event.data\n   - Pass to gatherContext step.invoke\n   - Save mcpsUsed to ResearchJob on completion\n\n4. Update type definitions throughout the chain\n\n5. Add credential loading for MCP clients:\n   - Decrypt credentials from database\n   - Pass to MCP clients via environment or config",
        "testStrategy": "Integration tests for full pipeline with various MCP selections. Verify credentials are passed correctly.",
        "priority": "high",
        "dependencies": ["19"],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into actions update, event schema update, orchestrator update, and credential loading."
      },
      {
        "id": "25",
        "title": "Enhance Fact-Checker for Cross-MCP Validation",
        "description": "Update fact-checker agent to validate claims across multiple MCP sources with special handling for Reddit opinions.",
        "details": "Update `/src/inngest/functions/agents/fact-checker-agent.ts`:\n\n1. Update input to receive per-MCP results:\n   - mcpResults: Record<string, ContextItem[]>\n   - sources: string[] (which MCPs were used)\n\n2. Implement cross-source claim validation:\n   - Extract key claims from each MCP's results\n   - Compare claims across sources\n   - Identify agreement (claim in 2+ sources) vs disagreement\n\n3. Add confidence scoring:\n   - High confidence: claim appears in 2+ authoritative sources\n   - Medium confidence: claim in 1 authoritative source\n   - Low confidence: claim only in Reddit (community opinion)\n   - Flag: conflicting claims between sources\n\n4. Special handling for Reddit:\n   - Mark as 'community opinion' not 'fact'\n   - Weight by upvotes/awards\n   - Note when Reddit contradicts authoritative sources\n\n5. Update output format:\n   - Add confidenceScore to each claim\n   - Add sourceAgreement field\n   - Add conflicts array for contradictions\n\n6. Update realtime channel:\n   - Add 'fact-check-progress' topic\n   - Stream claim validation as it happens",
        "testStrategy": "Unit tests for claim extraction and comparison. Test confidence scoring logic. Test Reddit special handling.",
        "priority": "medium",
        "dependencies": ["19", "24"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into input update, claim validation, confidence scoring, Reddit handling, output format, and realtime updates."
      },
      {
        "id": "26",
        "title": "Setup Next.js DevTools MCP",
        "description": "Configure Next.js DevTools MCP server for Dev Agents (Droid, Claude Code) to enable automated upgrade diagnostics and Next.js 16+ runtime features.",
        "details": "Configure Next.js DevTools MCP for development agents:\n\n1. Add `next-devtools` configuration to `.mcp.json`:\n   ```json\n   {\n     \"next-devtools\": {\n       \"command\": \"npx\",\n       \"args\": [\"-y\", \"next-devtools-mcp@latest\"]\n     }\n   }\n   ```\n\n2. Test MCP server connection with `npx next-devtools-mcp@latest`\n\n3. Verify available tools:\n   - `init` - Initialize context and access documentation\n   - `upgrade_nextjs_16` - Execute Next.js 16 upgrade\n   - `get_errors` - Detect build/runtime errors (Next.js 16+)\n   - `get_routes` - Inspect application routes\n   - `get_server_actions` - Debug Server Actions\n\n4. (Optional) Add custom instructions in `.claude/instructions` for auto-init\n\n5. Document MCP setup in `.factory/rules/` or project docs\n\nFiles involved: `.mcp.json`, `.claude/instructions`\n\nNote: This is a DEV AGENT tool, NOT for Inngest AgentKit production agents.",
        "testStrategy": "MCP server connectivity test. Verify all tools are accessible. Confirm documentation is available to Dev Agents.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": "27",
        "title": "Backup Pre-Upgrade",
        "description": "Create complete backup before Next.js 16 upgrade for rapid rollback in case of critical issues.",
        "details": "Create safe backup before upgrade:\n\n1. Create git branch: `git checkout -b backup/pre-next16-upgrade`\n\n2. Commit current state with detailed message including:\n   - Current Next.js version\n   - Current React version\n   - All dependency versions\n   - State description\n\n3. Create release tag: `git tag v1.0-next15-stable`\n\n4. Push backup branch and tag to GitHub:\n   ```bash\n   git push origin backup/pre-next16-upgrade\n   git push origin v1.0-next15-stable\n   ```\n\n5. Document current dependencies in `UPGRADE/UPGRADE_LOG.md`:\n   - Next.js version: 15.5.7\n   - React version\n   - Other critical dependencies\n   - Backup date/time\n   - Backup branch and tag\n\nFiles: `.git/`, `UPGRADE_LOG.md`, `package.json`, `package-lock.json`\n\nAcceptance Criteria:\n- Backup branch created and pushed\n- Release tag v1.0-next15-stable applied\n- Dependencies documented in UPGRADE_LOG.md",
        "testStrategy": "Verify branch exists on GitHub. Verify tag applied. Verify UPGRADE_LOG.md contains dependency info.",
        "priority": "critical",
        "dependencies": ["26"],
        "status": "pending",
        "subtasks": [],
        "complexity": 1,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": "28",
        "title": "Execute Next.js 16 Upgrade",
        "description": "Execute automated Next.js 15 ‚Üí 16 upgrade using upgrade_nextjs_16 tool from Next.js DevTools MCP.",
        "details": "Use Next.js DevTools MCP to perform safe automated upgrade:\n\n1. Initialize context: Call `init` tool to establish DevTools context and access official Next.js documentation\n\n2. Execute upgrade: Call `upgrade_nextjs_16` tool which:\n   - Automatically applies official Next.js codemods\n   - Updates package.json and dependencies\n   - Handles breaking changes automatically\n\n3. Review codemods applied:\n   - Check which files were modified\n   - Review suggestions from tool output\n   - Document all automatic changes\n\n4. Run `npm install` to update lockfile\n\n5. Verify breaking changes documentation:\n   - Async Request APIs (cookies, headers, params)\n   - Cache Components (new pattern in Next.js 16)\n   - Metadata APIs (async changes)\n   - Turbopack becomes default\n   - App Router stabilizations\n\n6. Document breaking changes resolved in `UPGRADE_LOG.md`:\n   - What changed\n   - How fixed\n   - Files modified\n\nFiles modified: `package.json`, `package-lock.json`, `next.config.js`, `src/**/*.ts(x)`, `UPGRADE_LOG.md`\n\nAcceptance Criteria:\n- Next.js updated to 16.x.x\n- All codemods applied\n- npm install successful\n- Breaking changes documented",
        "testStrategy": "Verify package.json shows Next.js 16.x. Run npm install without errors. Check codemods were applied correctly.",
        "priority": "high",
        "dependencies": ["26", "27"],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break into: DevTools init, upgrade execution, codemod review, npm install, breaking changes verification, documentation"
      },
      {
        "id": "29",
        "title": "Post-Upgrade Diagnostics",
        "description": "Verify application state post-upgrade using Next.js 16+ runtime diagnostics tools.",
        "details": "Use Next.js DevTools MCP diagnostic tools (available only in Next.js 16+):\n\n1. Start dev server:\n   ```bash\n   npm run dev\n   ```\n   Keep running in background for diagnostics\n\n2. Run diagnostics tools:\n   - `get_errors`: Detect build errors and runtime errors\n   - `get_routes`: Verify all routes configured correctly\n   - `get_server_actions`: Check Server Actions setup\n   - `get_dev_server_url`: Verify dev server endpoint\n\n3. Address critical errors:\n   - Fix all build-blocking errors\n   - Resolve runtime errors from errors log\n   - Verify route configuration\n\n4. Type-check:\n   ```bash\n   npm run type-check\n   ```\n\n5. Document findings in `UPGRADE_LOG.md`:\n   - Errors found and fixed\n   - Routes verified\n   - Server Actions status\n   - Any warnings or issues\n\nFiles: Dev server runtime, `UPGRADE_LOG.md`, source files\n\nTools from MCP: `get_errors`, `get_routes`, `get_server_actions`, `get_dev_server_url`\n\nAcceptance Criteria:\n- Dev server running without critical errors\n- Build successful\n- Type-check passed\n- All critical errors resolved and documented",
        "testStrategy": "Run dev server and verify no critical errors. Run get_errors and verify output. Type-check completes successfully.",
        "priority": "high",
        "dependencies": ["28"],
        "status": "pending",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": "30",
        "title": "Testing & Validation",
        "description": "Execute comprehensive test suite to validate all functionality works correctly after Next.js 16 upgrade.",
        "details": "Run full test suite to ensure upgrade didn't break functionality:\n\n1. Unit Tests:\n   ```bash\n   npm run test\n   ```\n   Verify all unit tests pass\n\n2. E2E Tests:\n   ```bash\n   npm run test:e2e\n   ```\n   Verify all Playwright E2E tests pass\n\n3. Test Coverage:\n   ```bash\n   npm run test:coverage\n   ```\n   Verify coverage threshold met\n\n4. Manual Testing:\n   - Test critical user flows manually\n   - Verify UI interactions work\n   - Test form submissions\n   - Test navigation\n\n5. Inngest Validation:\n   - Verify Inngest orchestrator workflow functioning\n   - Test Inngest realtime channels working\n   - Verify event triggers working\n   - Check function logs for errors\n\n6. Database Operations:\n   - Verify Prisma queries working\n   - Test database migrations\n   - Test CRUD operations\n\nFiles: Test configs, test files, Inngest functions, Prisma schema\n\nTest Checklist:\n- [ ] Unit tests passed\n- [ ] E2E tests passed\n- [ ] Inngest orchestrator working\n- [ ] Realtime channels functional\n- [ ] Database operations functional\n- [ ] Coverage threshold met\n\nAcceptance Criteria:\n- All tests passing\n- Inngest functions operational\n- Realtime channels working\n- Database operations functional",
        "testStrategy": "Run all test commands. Verify exit codes are 0. Check Inngest dashboard for successful runs. Verify no errors in logs.",
        "priority": "high",
        "dependencies": ["29"],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break into: Unit tests, E2E tests, Inngest validation, database operations, manual testing, coverage verification"
      },
      {
        "id": "31",
        "title": "Setup shadcn MCP Server",
        "description": "Configure shadcn MCP server for Dev Agents to enable automated UI component management via natural language.",
        "details": "Configure shadcn MCP for component management:\n\n1. Add `shadcn` configuration to `.mcp.json`:\n   ```json\n   {\n     \"shadcn\": {\n       \"command\": \"npx\",\n       \"args\": [\"shadcn@latest\", \"mcp\"]\n     }\n   }\n   ```\n\n2. Verify `components.json` exists in project root\n\n3. Test MCP server connection:\n   ```bash\n   npx shadcn@latest mcp\n   ```\n\n4. Verify available tools:\n   - `list-registries` - List configured registries\n   - `list-components` - List available components\n   - `search-registry` - Search components by name/tag\n   - `add-component` - Install components via natural language\n\n5. (Optional) Configure private registries in `components.json` if needed\n\n6. Test component installation with natural language:\n   ```\n   \"Add button and card components to my project\"\n   ```\n\nFiles: `.mcp.json`, `components.json`, `src/components/ui/`\n\nNote: This is a DEV AGENT tool for UI component management. It's different from production Inngest AgentKit MCPs.\n\nAcceptance Criteria:\n- shadcn MCP responds correctly\n- list-components tool works\n- add-component successfully installs test component\n- Natural language commands functional",
        "testStrategy": "Test MCP connection. Run list-components and verify output. Install test component with natural language. Verify component files created.",
        "priority": "medium",
        "dependencies": ["30"],
        "status": "pending",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": "32",
        "title": "Documentation & Knowledge Sharing",
        "description": "Update project documentation with Next.js 16 upgrade details and newly configured Dev MCP tools.",
        "details": "Update project documentation to reflect Next.js 16 and new Dev MCP tools:\n\n1. Update `README.md`:\n   - Update Next.js version from 15 to 16\n   - List newly available Dev MCP tools\n   - Add link to MCP setup guide\n\n2. Create/Update `docs/MCP_SETUP.md`:\n   - Guide for configuring Next.js DevTools MCP\n   - Guide for configuring shadcn MCP\n   - Example MCP server configurations\n   - Troubleshooting common MCP issues\n\n3. Update `AGENTS.md`:\n   - Add section: \"Dev MCP Tools (Next.js DevTools, shadcn)\"\n   - Explain difference between Dev MCPs and Inngest AgentKit production MCPs\n   - Document how Dev Agents (Droid, Claude Code) use these tools\n   - Add workflow examples\n\n4. Update `docs/DEVELOPMENT.md`:\n   - Add Next.js DevTools workflow\n   - Document how to use DevTools MCP for debugging\n   - Add examples of common diagnostic commands\n\n5. Finalize `UPGRADE_LOG.md`:\n   - Include summary of upgrade process\n   - List all breaking changes resolved\n   - Document performance impacts\n   - Add notes and recommendations\n\n6. Update `CHANGELOG.md`:\n   - Add entry for Next.js 16 upgrade\n   - Document new MCP tools configured\n   - Note version numbers\n\nFiles: README.md, docs/MCP_SETUP.md, AGENTS.md, docs/DEVELOPMENT.md, UPGRADE_LOG.md, CHANGELOG.md\n\nAcceptance Criteria:\n- All documentation updated and complete\n- MCP setup guides clear and comprehensive\n- Examples provided for common use cases\n- Breaking changes documented\n- Dev vs Production MCPs clearly distinguished",
        "testStrategy": "Review all documentation for accuracy. Verify links work. Test examples in guides.",
        "priority": "medium",
        "dependencies": ["31"],
        "status": "pending",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": "33",
        "title": "Production Deployment Preparation",
        "description": "Prepare application for production deployment with Next.js 16, verifying optimized build and Vercel configurations.",
        "details": "Prepare for production deployment:\n\n1. Production Build:\n   ```bash\n   npm run build\n   ```\n   Verify build completes without errors\n\n2. Analyze Bundle:\n   - Check bundle size output from build\n   - Identify large chunks\n   - Note optimizations applied\n   - Document bundle size changes\n\n3. Verify Environment:\n   - Check all required environment variables are set\n   - Verify Vercel environment variables configured\n   - Test with production environment values locally\n\n4. Test Production Build Locally:\n   ```bash\n   npm run start\n   ```\n   - Verify app runs from production build\n   - Test critical user flows\n   - Check performance\n\n5. Turbopack Configuration:\n   - If Turbopack enabled (default in Next.js 16), verify setup\n   - Test Turbopack build performance\n   - Document any Turbopack-specific configuration\n\n6. Environment Setup:\n   - Update `.env.example` if needed\n   - Verify all environment variables documented\n   - Check Inngest production endpoint configured\n\n7. Inngest Production:\n   - Verify Inngest production endpoint configured\n   - Test production event sending\n   - Verify function triggers work in production\n\n8. Deploy Preview:\n   - Create Vercel deploy preview\n   - Test full deployment flow\n   - Verify preview deployment succeeds\n\nFiles: next.config.js, .env.example, .vercel/, vercel.json, UPGRADE_LOG.md\n\nProduction Checklist:\n- [ ] Production build completed without errors\n- [ ] Bundle size analyzed and optimized\n- [ ] Environment variables verified\n- [ ] App runs from production build\n- [ ] Inngest production endpoint configured\n- [ ] Deploy preview tested\n\nAcceptance Criteria:\n- Production build successful\n- Bundle size analyzed\n- All environment variables configured\n- Inngest production ready\n- Deploy preview tested successfully",
        "testStrategy": "Run production build. Test locally with npm start. Verify all critical features work. Test deploy preview.",
        "priority": "medium",
        "dependencies": ["32"],
        "status": "pending",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      }
    ],
    "metadata": {
      "version": "1.1.0",
      "lastModified": "2026-01-29T00:00:00.000Z",
      "taskCount": 25,
      "completedCount": 2,
      "tags": [
        "master",
        "mcp-upgrade"
      ]
    }
  }
}